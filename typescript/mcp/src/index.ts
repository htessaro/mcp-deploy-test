// This file was generated by liblab | https://liblab.com/

import { McpServer, RequestConfig } from 'mcp-server';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

const server = new McpServer({
  name: 'mcp-server',
  version: '1.0.0',
});

const mcpServer = new McpServer({
  token: process.env.TOKEN || '',
  baseUrl: process.env.BASE_URL || 'http://api.thecatapi.com/v1',
});

type ApiResponse = {
  content: Array<{
    type: string;
    text: string;
  }>;
  isError?: boolean;
};

interface ImagesListSearchOrRandomParams {
  size?: string;
  mimeTypes?: string;
  format?: string;
  hasBreeds?: boolean;
  order?: string;
  page?: number;
  limit?: number;
  contentType?: string;
  xApiKey?: string;
}

interface GetImagesBkIEhN3pGParams {
  xApiKey?: string;
}

interface GetImagesParams {
  xApiKey: string;
  limit?: number;
  page?: number;
  order?: string;
  contentType?: string;
}

interface CreateImagesUploadParams {
  xApiKey: string;
  contentType?: string;
}

interface DeleteImagesByImageIdParams {
  contentType?: string;
  xApiKey?: string;
}

interface GetImagesByImageIdBreedsParams {
  contentType?: string;
}

interface CreateImagesByImageIdBreedsParams {
  xApiKey: string;
  contentType?: string;
}

interface DeleteImagesByImageIdBreedsByBreedIdParams {
  xApiKey: string;
  contentType?: string;
}

interface GetBreedsParams {
  xApiKey: string;
  limit?: number;
  page?: number;
  contentType?: string;
}

interface GetBreedsByBreedIdParams {
  contentType?: string;
}

interface GetBreedsSearchParams {
  q?: string;
  attachImage?: number;
}

interface GetBreedsByBreedIdFactsParams {
  limit?: number;
  page?: number;
  order?: string;
}

interface GetFavouritesParams {
  xApiKey: string;
  contentType?: string;
}

interface CreateFavouritesParams {
  xApiKey: string;
  contentType?: string;
}

interface GetFavouritesByFavouriteIdParams {
  xApiKey: string;
  contentType?: string;
}

interface DeleteFavouritesByFavouriteIdParams {
  xApiKey: string;
  contentType?: string;
}

interface GetVotesParams {
  xApiKey: string;
  contentType?: string;
}

interface CreateVotesParams {
  xApiKey: string;
  contentType?: string;
}

interface GetVotesByVoteIdParams {
  xApiKey: string;
  contentType?: string;
}

interface DeleteVoteByVoteIdParams {
  xApiKey: string;
  contentType?: string;
}

/**
 * Formats an error into a standardized API response.
 *
 * @param {Error} error - The error object to format.
 * @returns {ApiResponse} The formatted error response with a message.
 */
function formatErrorResponse(error: Error): ApiResponse {
  return {
    content: [
      {
        type: 'text',
        text: `Error: ${error.message || 'Unknown error'}`,
      },
    ],
    isError: true,
  };
}

/**
 * Formats successful data into a standardized API response.
 *
 * @param {*} data - The data to include in the response. Can be an object, string, number, etc.
 * @returns {ApiResponse} The formatted success response.
 */
function formatSuccessResponse(data: any): ApiResponse {
  let text: string;

  if (typeof data === 'object') {
    text = JSON.stringify(data, null, 2);
  } else {
    text = String(data);
  }

  return {
    content: [
      {
        type: 'text',
        text,
      },
    ],
  };
}

/**
 * Wraps a handler function to inject environment variables into parameters.
 * Loads defaults for existing params and adds any other relevant env vars.
 *
 * @param {Function} handler - The original handler function to wrap.
 * @returns {Function} A handler with environment variable injection.
 */
function withDefaultParams(handler: any) {
  return async (args: any) => {
    const newArgs = args ? { ...args } : {};
    newArgs.params = newArgs.params || {};

    // Track which env vars we've already processed
    const processedEnvVars = new Set();

    // Fill in missing params from env vars
    for (const paramName in newArgs.params) {
      if (newArgs.params[paramName] !== undefined && newArgs.params[paramName] !== '') {
        continue;
      }

      const envVarFormats = [
        paramName,
        paramName.toUpperCase(),
        paramName.toLowerCase(),
        paramName.replace(/([A-Z])/g, '_$1').toUpperCase(),
      ];

      for (const envVarName of envVarFormats) {
        if (process.env[envVarName] !== undefined) {
          newArgs.params[paramName] = process.env[envVarName];
          processedEnvVars.add(envVarName);
          break;
        }
      }
    }

    // Add remaining env vars that weren't matched
    for (const envVarName in process.env) {
      if (!processedEnvVars.has(envVarName) && newArgs.params[envVarName] === undefined) {
        newArgs.params[envVarName] = process.env[envVarName];
      }
    }

    // Remove empty params
    Object.keys(newArgs.params).forEach((key) => {
      if (newArgs.params[key] === undefined || newArgs.params[key] === '') {
        delete newArgs.params[key];
      }
    });

    return handler(newArgs);
  };
}

const RequestConfigSchema = z
  .object({
    retry: z
      .object({
        attempts: z.number().describe('Number of times a request should be retried upon failure'),
        delayMs: z.number().optional().describe('Delay in milliseconds between retry attempts'),
      })
      .optional()
      .describe('Configuration for request retry behavior'),

    validation: z
      .object({
        responseValidation: z
          .boolean()
          .optional()
          .describe('Whether the response should be validated against a schema'),
      })
      .optional()
      .describe('Settings related to request and response validation'),

    baseUrl: z.string().optional().describe('Base URL for the API requests'),
  })
  .optional()
  .describe('Configuration object for customizing request behavior');

// Images Service
server.tool(
  'images_list_search_or_random',
  "Searches or returns Random selection from all approved images. Default is to return RANDOM images, but with an API-Key you can use 'orderDESC' or 'orderASC' along with the 'page' and 'limit' parameters to paginate through them in the order they were approved. Pagination-Count, Pagination-Page, and Pagination-Limit headers are present in the response so you know the total number of images that can be paginated through for the passed search filters.",
  {
    params: z
      .object({
        size: z.string().optional().describe('optional thumb , small, med or full - small is perfect for Discord'),
        mimeTypes: z
          .string()
          .optional()
          .describe('optional a comma separated string of types to return e.g. jpg,png for static, or gif for gifs'),
        format: z.string().optional().describe('optional json  src'),
        hasBreeds: z.boolean().optional().describe('optional - only return images with breed data'),
        order: z.string().optional().describe('optional defaultRANDOM - RANDOM  ASC  DESC'),
        page: z.number().optional().describe('optional paginate through results'),
        limit: z.number().optional().describe('optional number of results to return, up to 25 with a valid API-Key'),
        contentType: z.string().optional().describe('Content-Type'),
        xApiKey: z.string().optional().describe('optional without it only the a basic set of images can be searched'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { params?: ImagesListSearchOrRandomParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.images.imagesListSearchOrRandom(args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_images_bk_i_eh_n3p_g',
  'Get the raw analysis results for any uploaded image',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('optional  will save this request to your account analytics'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { params?: GetImagesBkIEhN3pGParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.images.getImagesBkIEhN3pG(args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_images',
  "Only returns images from your account, uploaded via 'apiv1imagesupload'",
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('- will return all the images from your account'),
        limit: z.number().optional().describe('Optional number of images to return valid  1 to 10 - default 1'),
        page: z
          .number()
          .optional()
          .describe('Optional only works if accountid is present to page through your own uploads'),
        order: z
          .string()
          .optional()
          .describe('Optional only works if accountid is present, either ASC or DESC - ascending or descending.'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { params: GetImagesParams; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.images.getImages(args.params, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

server.tool(
  'create_images_upload',
  "Make sure you're using the right field to send the image, and Content-Type header",
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('- saves the uploaded image to your account.'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    body: z.any().optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { body?: any; params: CreateImagesUploadParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.images.createImagesUpload(args.body || {}, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'delete_images_by_image_id',
  'imagesimageid',
  {
    imageId: z.string(),
    params: z
      .object({
        contentType: z.string().optional().describe('Content-Type'),
        xApiKey: z.string().optional().describe('x-api-key'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      imageId: string;
      params?: DeleteImagesByImageIdParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.images.deleteImagesByImageId(args.imageId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_images_by_image_id_breeds',
  'imagesimageidbreeds',
  {
    imageId: z.string(),
    params: z
      .object({
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      imageId: string;
      params?: GetImagesByImageIdBreedsParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.images.getImagesByImageIdBreeds(args.imageId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'create_images_by_image_id_breeds',
  'imagesimageidbreeds',
  {
    imageId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('- for now, you can only tag your own images with a breed'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    body: z.any().optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      imageId: string;
      body?: any;
      params: CreateImagesByImageIdBreedsParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) -
          server.images.createImagesByImageIdBreeds(args.imageId, args.body || {}, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'delete_images_by_image_id_breeds_by_breed_id',
  'imagesimageidbreedsbreedid',
  {
    imageId: z.string(),
    breedId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('- only you can delete breeds from your images'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      imageId: string;
      breedId: string;
      params: DeleteImagesByImageIdBreedsByBreedIdParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) -
          server.images.deleteImagesByImageIdBreedsByBreedId(
            args.imageId,
            args.breedId,
            args.params,
            args.requestConfig,
          );

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

// Breeds Service
server.tool(
  'get_breeds',
  'breeds',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('required API key to access the facts'),
        limit: z.number().optional().describe('limit'),
        page: z.number().optional().describe('page'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { params: GetBreedsParams; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.breeds.getBreeds(args.params, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

server.tool(
  'get_breeds_by_breed_id',
  'breedsbreedid',
  {
    breedId: z.string(),
    params: z
      .object({
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      breedId: string;
      params?: GetBreedsByBreedIdParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.breeds.getBreedsByBreedId(args.breedId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_breeds_search',
  'Search Breeds',
  {
    params: z
      .object({
        q: z.string().optional().describe('search term for breed name'),
        attachImage: z.number().optional().describe('optional whether to attach the referenceimageid image or not'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { params?: GetBreedsSearchParams; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.breeds.getBreedsSearch(args.params, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

// Facts Service
server.tool(
  'get_breeds_by_breed_id_facts',
  "Get one or more facts about the Species. For more at a time just update the 'limit' field, and to paginate through them just increment the 'page' field. The response headers have the pagination details, such as how many there are in total, what page you're on, and the current amount per page. To redorder change the order to ASC for ascending order, DESC for descending, and RAND for random order.",
  {
    breedId: z.string(),
    params: z
      .object({
        limit: z.number().optional().describe('limit'),
        page: z.number().optional().describe('page'),
        order: z.string().optional().describe('order'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      breedId: string;
      params?: GetBreedsByBreedIdFactsParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.facts.getBreedsByBreedIdFacts(args.breedId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_facts',
  "Get one or more Random facts and the Species. For more at a time just update the 'limit' field",
  {
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.facts.getFacts(args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

// Favourites Service
server.tool(
  'get_favourites',
  'favourites',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { params: GetFavouritesParams; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.favourites.getFavourites(args.params, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

server.tool(
  'create_favourites',
  'favourites',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    body: z.any().optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { body?: any; params: CreateFavouritesParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.favourites.createFavourites(args.body || {}, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_favourites_by_favourite_id',
  'favouritesfavouriteid',
  {
    favouriteId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      favouriteId: string;
      params: GetFavouritesByFavouriteIdParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) - server.favourites.getFavouritesByFavouriteId(args.favouriteId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'delete_favourites_by_favourite_id',
  'favouritesfavouriteid',
  {
    favouriteId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: {
      favouriteId: string;
      params: DeleteFavouritesByFavouriteIdParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      try {
        const { data } =
          (await mcp) -
          server.favourites.deleteFavouritesByFavouriteId(args.favouriteId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

// Votes Service
server.tool(
  'get_votes',
  'votes',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { params: GetVotesParams; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.votes.getVotes(args.params, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

server.tool(
  'create_votes',
  'votes',
  {
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    body: z.any().optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { body?: any; params: CreateVotesParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.votes.createVotes(args.body || {}, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'get_votes_by_vote_id',
  'votesvoteid',
  {
    voteId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { voteId: string; params: GetVotesByVoteIdParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.votes.getVotesByVoteId(args.voteId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

server.tool(
  'delete_vote_by_vote_id',
  'votesvoteid',
  {
    voteId: z.string(),
    params: z
      .object({
        xApiKey: z.string().optional().describe('x-api-key'),
        contentType: z.string().optional().describe('Content-Type'),
      })
      .optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(
    async (args: { voteId: string; params: DeleteVoteByVoteIdParams; requestConfig?: RequestConfig }): Promise<any> => {
      try {
        const { data } = (await mcp) - server.votes.deleteVoteByVoteId(args.voteId, args.params, args.requestConfig);

        return formatSuccessResponse(data);
      } catch (error) {
        return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
      }
    },
  ),
);

// Webhooks Service
server.tool(
  'create_webhooks',
  'Create Webhook',
  {
    body: z.any().optional(),
    requestConfig: RequestConfigSchema,
  },
  withDefaultParams(async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
    try {
      const { data } = (await mcp) - server.webhooks.createWebhooks(args.body || {}, args.requestConfig);

      return formatSuccessResponse(data);
    } catch (error) {
      return formatErrorResponse(error instanceof Error ? error : new Error(String(error)));
    }
  }),
);

// Start the server
async function main(): Promise<void> {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch((error) => {
  console.error('Fatal error in main():', error);
  process.exit(1);
});
